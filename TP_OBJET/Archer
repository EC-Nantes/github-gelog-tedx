/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package org.centrale.objet.WoE;

import java.util.ArrayList;
import java.util.Random;

/**
 * Classe de gestion des archers
 * @author vdufo
 */
public class Archer extends Personnage implements Combattant,Deplacable{
    private int nbFleches;
    
    /**
     * Constructeur d'un archer
     * @param n nom 
     * @param pV point de vie
     * @param pvMax point de vie max
     * @param dA degat d'attaque
     * @param pPar point de parade
     * @param paAtt pourcentage d'attaque
     * @param paPar pourcentage de parade
     * @param dMax distance d'attaque max
     * @param p position
     * @param nbFleches nombre de flèches
     */
    public Archer(String n, int pV, int pvMax, int dA, int pPar, int paPar,int paAtt, int dMax, Point2D p,int nbFleches){
        super(n, pV,pvMax, dA, pPar, paPar, paAtt, dMax, p);
        this.nbFleches=nbFleches;
        
        
    }

    public int getNbFleches() {
        return nbFleches;
    }

    public void setNbFleches(int nbFleches) {
        this.nbFleches = nbFleches;
    }

    /**
     *
     * @param a
     */
    public Archer(Archer a){
        super((Personnage)a);   
    }

    /**
     *
     */
    public Archer(){
        super("archer", 40,40, 10, 1, 10, 5, 30, new Point2D(5,3));
        this.nbFleches=12;
        
    }
    
    @Override
    public String nomClasse(){
        return "Archer";
    }
    
    /**
     * 
     * @param c creature que va combattre l'archer
     * @param monde monde dans lequel se passe le combat
     * @param liste liste des creatures qui meurent a actualiser à chaque fois
     */
    @Override
    public void combattre(Creature c,World monde, ArrayList<Creature> liste){
        Random alea = new Random();
            /**combat a distance*/
        if((Point2D.distancecrea(c.getPos(),this.getPos())>1)&&(Point2D.distancecrea(c.getPos(),this.getPos())<this.getDistAttMax())){
            if ((alea.nextInt(101)>this.getPageAtt())&&(this.getNbFleches()>0)){
                if(this.nbFleches == 0){
                    System.out.println("L'archer n'a plus de flèches, il ne peut pas combattre");
                }
                else{
                    if (alea.nextInt(101)>c.getPagePar()){
                    c.setPtVie(c.getPtVie()-this.getDegAtt());
                    this.setNbFleches(this.getNbFleches()-1);
                    }
                }
            }
        }
        if (c.getPtVie() <=0){
            System.out.println("La creature "+((Deplacable)c).nomClasse()+" est morte, tuee par un archer !");
            liste.add(c);
        }
     }
    
    private boolean verif(Point2D A, ArrayList<Point2D> liste){
       boolean rep = false;
        for(Point2D element: liste){
            if (A.equals(element)){
                rep = true;
                break;
            }
        } 
        return rep;
    }
    
    private void modifListe(ArrayList<Point2D> liste, Point2D anciennePos, Point2D nouvellePos){
        for (int i =0;i<liste.size();i++){
            if (liste.get(i).equals(anciennePos)){
                liste.set(i, nouvellePos);
            }
        }
    }
    
    /**
     * Méthode sans paramètre d'entrée qui modifie en place la position d'un personnage.
     * Il peut se déplacer de manière aléatoire sur une case adjacente à la sienne.
     * On suppose qu'il ne peut pas rester sur la même case.
     * @param liste liste de Point2D cette liste représente toutes les cases occupées par les elements du jeu
     */
    @Override
    public void deplace(ArrayList<Point2D> liste){
        Random genx = new Random();
        Random geny = new Random();
        int dx = 0;
        int dy = 0;
        while (dx == 0 && dy == 0){
        dx = genx.nextInt(3)-1;
        dy = geny.nextInt(3)-1;   
        }
        Point2D tempo = new Point2D(this.getPos());
        tempo.translate(dx,dy);
        
        // vérification qu'il est dans la liste
        boolean rep = verif(tempo,liste);
        while(rep){
            tempo.translate(-dx,-dy);
            while (dx == 0 && dy == 0){
                dx = genx.nextInt(3)-1;
                dy = geny.nextInt(3)-1;   
            }
            tempo.translate(dx,dy);
            rep = verif(tempo,liste);
        }
        
        //Si on sort de la boucle while, alors positionpas dans la liste on deplace et on l'actualise
        modifListe(liste,tempo,this.getPos());
        this.getPos().translate(dx,dy);  

    }
        /**
     *Méthode qui affiche le nombre de point de vie et la position d'un personnage
     */
    @Override
    public void affiche(){
        // Quand on cherche à afficher un monstre, on veut voir son nombre de point de vie et sa position
        //System.out.println("Point de vie : "+ this.getPtVie());
        //System.out.println("Position : "+ this.getPos().toString());      
        System.out.printf(" "+'A'+" ");
    }
}
